<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Sort Puzzle</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f4f4f4;
            margin: 20px;
        }
        .container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }
        .tube {
            width: 60px;
            height: 200px;
            border: 2px solid #333;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            overflow: hidden;
            background-color: white;
            cursor: pointer;
        }
        .selected{
            border: 2px dashed #0000ff;
        }
        .color-segment {
            width: 100%;
            height: 40px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        button {
            margin-top: 13px;
            border: none;
            padding: 10px;
            width: 100px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>Color Sort Puzzle</h1>
    <p>Click a tube to select, then click another to pour.</p>

    <div class="container" id="gameBoard"></div>
    <button onclick="resetGame()">NEW</button>
    <button id = "undo" onclick="undo_it()">Undo</button>
    <button id = "save" onclick="save()">SAVE </button>
    <button id = "load" onclick="load()">LOAD</button>
    <input type="file" id="txtfiletoread" style="display:none;"></input>
    <br>
    <div class="container">
        <table>
            <tr>
                <td style="text-align: right">
                    <label for="n_blocks">Number of blocks for each color:</label>
                </td>
                <td>
                    <input type="number" id="n_blocks" value = "1" min = "1" onchange="number_update()"></input>
                </td>
            </tr>
            <tr>
                <td style="text-align: right">
                    <label for="n_colors">Number of colors:</label>
                </td>
                <td>
                    <input type="number" id="n_colors" value = "1" min = "2" onchange="number_update()"></input>
                </td>
            </tr>
            <tr>
                <td style="text-align: right">
                    <label for="n_empty">Number of empty tubes:</label>
                </td>
                <td>
                    <input type="number" id="n_empty" value = "1" min = "1" onchange="number_update()"></input>
                </td>
            </tr>       
        </table>
    </div>


    <script>
        function try_it(){
            console.log(JSON.stringify(score(tubes)))
            // let all_mvs = list_all_moves(tubes)
            // for(let i = 0;i< all_mvs.length;i++){
            //     let nxt = what_is_next(all_mvs[i],tubes)
            //     if(nxt.length == 1){
            //         if(all_mvs[i][0]==nxt[0][1] && all_mvs[i][1]==nxt[0][0])
            //             nxt = ["loop-end"]
            //     }
            //     console.log(JSON.stringify(all_mvs[i])+" -> "+ nxt.map(JSON.stringify).join(" "))
            // }
            n_color_m_empty(tubes)
            console.log("-------------------------")
        }


        function list_all_moves(tubes){
            let all_moves = []
            let n_columns = tubes.length
            for(let i =0;i<n_columns;i++){
                for( let j = 0;j<n_columns;j++){
                    if(tubes[i].length>0){
                        toTube = tubes[j]
                        colorToPour = tubes[i][tubes[i].length-1]
                        flag = (toTube.length === 0 || toTube[toTube.length - 1] === colorToPour )&&toTube.length < n_blocks
                        if(i!=j && flag) all_moves.push([i,j])
                    }
                }
            }
            //if(logit) console.log(all_moves.reduce((a,it)=> a+JSON.stringify(it)+"\n",""))
            return(all_moves)
        }
        function what_is_next(one_mv,tubes){
            let cur = JSON.parse(JSON.stringify(tubes))
            let tmp = cur[one_mv[0]].pop()
            cur[one_mv[1]].push(tmp)
            let next_mvs = list_all_moves(cur)
            return next_mvs//.reduce((a,it)=> a+JSON.stringify(it)+"\t","")
        }
        function tube_score(arr){
            //regardless of the contrain, how many steps or tubes need to sort out one tube.
            //equal the number of colors +1,unless the bottom of tubes 1 has all the same color.
            if(arr.length == 0) return 0;
            let b_color = arr[0];
            let ii = 0
            while(ii < arr.length &&  arr[ii] == b_color ) ii++;
            let unique = [...new Set(arr.slice(ii))];
            let ans = 1+unique.length
            return ans
        }
        function score(tubes){
            //let cur_tubes = JSON.parse(JSON.stringify(tubes))
            let result = tubes.map(it => tube_score(it))
            return result
        }

        function find_colors(this_color,tbs){
            let pos = []
            for(let i = 0;i < tbs.length;i++){
                for(let j = 0; j< tbs[i].length;j++){
                    if(tbs[i][j] == this_color){
                        pos.push([i,j])
                    }
                }
            }
            return pos
        }

        function ABO_2b(tbs_){
            if(n_blocks!=2) return;
            let tbs = JSON.parse(JSON.stringify(tbs_))
            let s = score(tbs)
            let ss = s.filter(it => it==2).length
            let tns = tbs.map(it => it.length)
            let pos_O = tns.indexOf(0)
            let pos_a = tns.indexOf(1)
            let pos_b = tns.indexOf(1,pos_a+1)
            let mvs = []
            //console.log(JSON.stringify([pos_a,pos_b,pos_O]))
            if(tbs[pos_a][0]==tbs[pos_b][0]){
                let tmp = tbs[pos_b].pop()
                tbs[pos_a].push(tmp)
                mvs.push([pos_b,pos_a])
                let sth = two_layer(tbs) //recursive call
                if(sth!=0){
                    mvs = mvs.concat(sth.mvs)
                    tbs = sth.tbs
                }
            }else{
                let a = find_colors(tbs[pos_a][0],tbs).filter(it => it[0]!=pos_a)
                if(a[0][1] == 1){
                    let tmp = tbs[a[0][0]].pop()
                    tbs[pos_a].push(tmp)
                    mvs.push([a[0][0],pos_a])
                }else{
                    let tmp = tbs[a[0][0]].pop()
                    tbs[pos_O].push(tmp)
                    mvs.push([a[0][0],pos_O])

                    tmp = tbs[pos_a].pop()
                    tbs[a[0][0]].push(tmp)
                    mvs.push([pos_a,a[0][0]])
                }
                let sth = ABO_2b(tbs)
                mvs = mvs.concat(sth.mvs)
                tbs = sth.tbs                
            }
            return({"mvs":mvs,"tbs":tbs})
        }

        function two_layer(tubes_top2_){
            if(n_blocks!=2 || n_empty < 2) 
                return 1;

            // let bottoms = tubes_top2.map((it,k) => typeof it[0] != 'undefined'?it[0]:-1)
            // let tops = tubes_top2.map((it,k) => typeof it[1] != 'undefined'?it[1]:-1)
            // let b_colors = bottoms.reduce(function (acc, curr) {
            //             return acc[curr] ? ++acc[curr] : acc[curr] = 1, acc
            //         }, {});
            let tubes_top2 = JSON.parse(JSON.stringify(tubes_top2_))

            let s = score(tubes_top2)
            let k = s.indexOf(2) //1 all the same, 0 empty
            if(k != -1){
                let e = s.indexOf(0)
                let mvs = []
                let tmp = tubes_top2[k].pop()
                tubes_top2[e].push(tmp)
                mvs.push([k,e])
                let sth = ABO_2b(tubes_top2)
                mvs = mvs.concat(sth.mvs)
                tubes_top2 = sth.tbs
                return({"mvs":mvs,"tbs":tubes_top2})
            }

            return 0
        }

        function count_color(tb,nc){
            let cc = Array(nc).fill(0)
            for(let ii = 0;ii<tb.length;ii++){
                cc[tb[ii]]++;
            }
            return cc
        }
        function n_color_m_empty(tbs_){
            let tbs = JSON.parse(JSON.stringify(tbs_))
            let nc = [...new Set(tbs.flat())].length
            let nb = tbs[0].length
            let cc = tbs.slice(0,nc).map(it => count_color(it,nc))
            let bb = cc.map(it => it.reduce((a,b)=>b<a?b:a,nb))
            let st = bb.reduce((a,it,k) => it<a.v?{"v":it,"k":k}:a,{"v":nb+1,"k":-1})
            let focus_tube = st.k
            console.log(JSON.stringify(bb))


        }
    </script>

    <script>

    // input: r,g,b in [0,1], out: h in [0,360) and s,v in [0,1]
function rgb2hsv(r,g,b) {
  let v=Math.max(r,g,b), c=v-Math.min(r,g,b);
  let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); 
  return [60*(h<0?h+6:h), v&&c/v, v];
}

// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]
function hsv2rgb(h,s,v) 
{                              
  let f= (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);     
  return [f(5),f(3),f(1)];       
}

function get_n_color(n){
    let rgb_f = Array(n).fill([0,0,0])
    //hues = seq(15, 375, length = n + 1)
    for(let i = 0;i<n;i++){
        rgb_f[i] = hsv2rgb(15+360/n*i,0.6,1)
    }
    let rgb = rgb_f.map(jt=>[Math.floor(jt[0]*255),Math.floor(jt[1]*255),Math.floor(jt[2]*255)])
              .map(it => `rgb(${it[0]},${it[1]},${it[2]})`)
    return rgb
}



        // Generate a shuffled stack of colors
function generateShuffledColors(n_blocks = 5,n_colors = 4,n_empty = 2) {

    //const seven_colors = ["#eeeeee","rgb(230, 20, 20)","rgb(10, 200, 10)","rgb(20, 20, 230)","orange","rgb(20, 230, 230)","magenta","rgb(140, 70, 20)"]
    //let colors = seven_colors.sort((a,b)=> Math.random() - Math.random()).slice(0,n_colors)
    //["red", "blue", "green", "yellow",];
    //const color_index = //get_n_color(n_colors)
    let colorStack = [];

    for(let color_index = 0;color_index<n_colors;color_index++)
        for (let i = 0; i < n_blocks; i++) {
            colorStack.push(color_index);
        }

    // Shuffle colors randomly
    // for (let i = colorStack.length - 1; i > 0; i--) {
    //     let j = Math.floor(Math.random() * (i + 1));
    //     [colorStack[i], colorStack[j]] = [colorStack[j], colorStack[i]];
    // }

    colorStack.sort((a,b)=> Math.random() - Math.random())

    // Distribute colors into 4 tubes + 2 empty ones
    const game = []
    for(let i = 0;i<n_colors;i++){
        game.push(colorStack.slice(i*n_blocks, (i+1)*n_blocks))
    }
    for(let i = 0;i<n_empty;i++){
        game.push([])
    }

    return game
}


function number_update(){
    const blocks = document.getElementById('n_blocks')
    const ncolors = document.getElementById('n_colors')
    const empty_tubes = document.getElementById('n_empty')

    n_blocks = blocks.value
    n_colors = ncolors.value
    n_empty = empty_tubes.value

    colors = get_n_color(n_colors)

    resetGame()
}


// Initialize tubes with shuffled colors
let n_blocks = 5
let n_colors = 4
let n_empty = 2
let tube_history = []
let selectedTube = null; // Track selected tube
let colors = get_n_color(n_colors)
let tubes = generateShuffledColors(n_blocks,n_colors,n_empty);
let ans0 = []
let keep_moving = true;
let autoid;

// Function to create the game board UI
function createGameBoard() {
    
    let board = document.getElementById("gameBoard");
    board.innerHTML = ""; // Clear old state

    tubes.forEach((tube, index) => {
        let tubeDiv = document.createElement("div");
        tubeDiv.classList.add("tube");
        tubeDiv.setAttribute("data-index", index);
        tubeDiv.style.height =(n_blocks*42).toString()+"px"

        // Create colored segments
        tube.forEach(color_index => {
            let segment = document.createElement("div");
            segment.classList.add("color-segment");
            segment.style.backgroundColor = colors[color_index];
            tubeDiv.appendChild(segment);
        });

        tubeDiv.addEventListener("click", () => selectTube(index)); // Click event
        board.appendChild(tubeDiv);
    });

    try_it()
}

// Function to handle tube selection & pouring logic
function selectTube(index) {
    let board = document.getElementById("gameBoard");

    if (selectedTube === null) {
        selectedTube = index;
        board.children[index].classList.add("selected");
    } else if(selectedTube == index ){
        selectedTube = null;
        board.children[index].classList.remove("selected");
    }else {
        pourLiquid(selectedTube, index);
        board.children[selectedTube].classList.remove("selected");
        selectedTube = null; // Reset selection after pouring
    }
}

// Function to pour liquid from one tube to another
function pourLiquid(fromIndex, toIndex) {
    let fromTube = tubes[fromIndex];
    let toTube = tubes[toIndex];

    if (fromTube.length === 0) return; // No liquid to pour

    let colorToPour = fromTube[fromTube.length - 1];

    // Check if we can pour (either empty tube or same color on top)
    while ((toTube.length === 0 || toTube[toTube.length - 1] ===  fromTube[fromTube.length - 1])&&toTube.length < n_blocks) {
        tube_history.push(JSON.parse(JSON.stringify(tubes)))
        colorToPour=fromTube.pop();
        toTube.push(colorToPour);
        createGameBoard(); // Update the UI
        checkWinCondition();
    }
}

// Function to check if all colors are sorted correctly
function checkWinCondition() {
    let allSorted = tubes.every(tube => tube.length === 0 || tube.every(color => color === tube[0]));

    if (allSorted) {
        console.log("ðŸŽ‰ Congratulations! You sorted all colors!")
        //setTimeout(() => alert("ðŸŽ‰ Congratulations! You sorted all colors!"), 200);
    }
}

function update_number(){
    const blocks = document.getElementById('n_blocks')
    const ncolors = document.getElementById('n_colors')
    const empty_tubes = document.getElementById('n_empty')
    
    //n_x are globals
    blocks.setAttribute("value",n_blocks)
    ncolors.setAttribute("value",n_colors)
    empty_tubes.setAttribute("value",n_empty)
}

// Function to reset the game
function resetGame() {
    update_number()
    colors = get_n_color(n_colors)
    tubes = generateShuffledColors(n_blocks,n_colors,n_empty);
    tube_history = []
    
    selectedTube = null;
    createGameBoard();

    let sth = two_layer(tubes)
    console.log(JSON.stringify(sth))
    ans0 = sth.mvs
}

function undo_it(){
    //console.log("undo_it is called")
    if(tube_history.length > 0){
        tubes = tube_history.pop()
       // console.log(tubes)
        createGameBoard();
        selectedTube = null;
    }
    //console.log("undo_it call is finished")
}

function save(){
    var json_game = JSON.stringify({"current":tubes,"history":tube_history,
                    "ps":[n_blocks,n_colors,n_empty]})

    var flag = tubes.every(tube => tube.length === 0 || tube.every(color => color === tube[0]));

    var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json_game);
    var tmp_node = document.createElement('a');
    tmp_node.setAttribute("href", dataStr);
    if(flag){
        tmp_node.setAttribute("download", "colorsort_"+Date.now() + ".json");
    }else{
        tmp_node.setAttribute("download", "colorsort_"+Date.now() + "_not_finished.json");
    }
    document.body.appendChild(tmp_node); // required for firefox
    tmp_node.click();
    tmp_node.remove();
    document.getElementById("save").blur();
}


function load(){
    if (window.File && window.FileReader && window.FileList && window.Blob) {
        var fileSelected = document.getElementById("txtfiletoread");
        fileSelected.click();
        fileSelected.addEventListener(
          "change",
          function (e) {
            if(fileSelected.files.length<1) return;
            //Set the extension for the file
            var fileExtension = /json/;
            //Get the file object
            var fileTobeRead = fileSelected.files[0];
            //Check of the extension match
            if (fileTobeRead.type.match(fileExtension)) {
              //Initialize the FileReader object to read the 2file
              var fileReader = new FileReader();
              fileReader.onload = function (e) {
                   //console.log(e)
                   let sth = JSON.parse(fileReader.result);
                   n_blocks = Number(sth.ps[0])
                   n_colors = Number(sth.ps[1])
                   n_empty  =Number(sth.ps[2])
                   colors = get_n_color(n_colors)
                   update_number()
                   tube_history = sth.history
                   tubes = sth.current
                   createGameBoard();
                   selectedTube = null;
              };
              fileReader.readAsText(fileTobeRead);
            }
          },
          false
        );
      } else {
        alert("Files are not supported");
      }
    document.getElementById("load").blur();
}


function auto_move(){
    if(ans0.length == 0){
        clearInterval(autoid);
        return 0;
    }
    const stp = ans0.shift();
    pourLiquid(stp[0],stp[1])
    if(keep_moving){
        autoid = setInterval(auto_move,250);
    }
}


document.onkeydown = function(event) {
    if (event.key === 'z' ||event.key === 'Z'|| event.key=='u'|| event.key=='U') {
        undo_it()
      }
      if(event.key === 'm'||event.key === 'M'){
        if(keep_moving){
            auto_move();
        }else{
            clearInterval(autoid);
        }
        keep_moving = !keep_moving;
    }
}


// Initialize the game
resetGame();

    </script>


</body>
</html>
